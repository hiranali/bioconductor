---
title: "Bioconductor - Packages"
author: "Hira Ali"
date: "2025-02-12"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}

if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

# To check the Bioconductor version
BiocManager::version()
```

```{r}
BiocManager::install("biocLite")
```

```{r}
# Need devtools to be able to downnload github repos
install.packages("devtools")
library(devtools)

# Downloading github repo
install_github("genomicsclass/ph525x")
```

```{r}
BiocManager::install("airway")

library(airway)

data(airway)

airway
```


## Loading Sample Dataset: BSgenome.Hsapiens.UCSC.hg19

```{r}
# Biocinstaller was renamed to BiocManager
library(BiocManager)
## need to increase timeout limit since the package is very large, and takes extra long especially on slow wifi
options(timeout = 1500) 
BiocManager::install("BSgenome.Hsapiens.UCSC.hg19")
```
```{r}
# Preview BSgenome.Hsapiens.UCSC.hg19 object
library(BSgenome.Hsapiens.UCSC.hg19)
BSgenome.Hsapiens.UCSC.hg19
```

```{r}
# naming an object as chr11seq that contains the bases of chromosome 11
chr11seq <- BSgenome.Hsapiens.UCSC.hg19[["chr11"]]
```

```{r}
# using the subseq function to select for a subset of the chromostome starting at base 1m, and of length 25 bases
subseq(chr11seq,start=10^6,width=25)
```

## Loading Sample Dataset: tissueGeneExpression

```{r}

#Downloading Github repo
install_github("genomicsclass/tissuesGeneExpression")

```
```{r}

library(tissuesGeneExpression)
data(tissuesGeneExpression)

# the rows labels of the matrix e are features, aka genes. the column labels are the samples.
# the entries of the matrix are gene expression measurements (in log scale) obtained using a microarray technology.
head(e[,1:5])

# tissue: A vector that labels each sample in e with its corresponding tissue type.
## the table shows the number of samples of each tissue type in this dataset.
table(tissue)

```

```{r}

# Once the tissuesGeneExpression package is loaded, and data(tissuesGeneExpression) is run, you have object e, tab, and tissue in your workspace. You can work with them separately but it is preferable in Bioconductor to unify them in an object.
# You can unify genomics data using SummarizedExperiment() function.

library(SummarizedExperiment)
tissSE = SummarizedExperiment(list(rma=e))
colData(tissSE) = DataFrame(tab)
```



```{r}
# To restrict to genes with 'phosphatase' in their names, use code like:
tissSE[ grep("phosphatase", rowData(tissSE)$genename), ]

```
# Data Management Testing

The GSE5859Subset dataset is a curated subset of gene expression data from the GEO series GSE5859, commonly used in educational contexts to illustrate high-throughput data analysis. As of now, this dataset is available through the GSE5859Subset package, which can be installed from GitHub. There isn't a more recent or updated version of this specific subset.

```{r}
# Install the remotes package (if not already installed)
install.packages("remotes")
# Use remotes to install the GSE5859Subset package from GitHub:
remotes::install_github("genomicsclass/GSE5859Subset")
# Load the package and dataset
library(GSE5859Subset)
data(GSE5859Subset)

```

## Testing

Just want to confirm that I pulled the correct dataset by referencing the main components i.e. # of samples, # of features, etc.

```{r}
# We can look at a gene expression table which includes 8793 expression features by 24 samples
dim(geneExpression)
```

```{r}
# Looking at the annotations about the genes for different fields (for each one of the features)
dim(geneAnnotation)
```

```{r}
# Looking at any additional information about the samples
dim(sampleInfo)
```

Using the ls() command, we can confirm that we have added three objects: geneAnnotation, geneExpression, and sampleInfo.

## Verify that these objects of interest can be coordinated.
Recall that we have:

- geneExpression: an object that contains N samples taken and a microarray with p features used to quantify mRNA abundance for p genes AKA a p x N matrix

- sampleInfo: describing the samples in detail, AKA N x r .dataframe

- geneAnnotation: providing more information about the features AKA p x q .dataframe

```{r}
# Comparing the file name field of the sampleInfo object with the column names of the geneExpression object
all.equal(sampleInfo$filename, colnames(geneExpression))
```

```{r}
# Comparing the row names of the geneExpression object with the probeID field of the geneAnnotation object
all.equal(row.names(geneExpression), geneAnnotation$PROBEID)
```

## Exploring the data

```{r}
head(geneAnnotation)
```

```{r}
head(geneExpression)
```

```{r}
head(row.names(geneExpression))
```

We can note here that p = genes in geneExpression = PROBEID in geneAnnotation

# Binding the tables together in an ExpressionSet

The ExpressionSet container manages all this information in one object. To improve the visibility of nomenclature for genes and samples, we improve the annotation for the individual components.

```{r}
rownames(sampleInfo) = sampleInfo$filename
rownames(geneAnnotation) = geneAnnotation$PROBEID
```

Now, we proceed to make the ExpressionSet object (leveraging the Biobase package):

```{r}
library(Biobase)
es5859 = ExpressionSet(assayData=geneExpression)
# pData = phenotype data; macroscopic information about the samples
pData(es5859) = sampleInfo
# fData = feature data; a little more info about the features than just the identifiers, including a gene symbol and the location where the genes are located on the chromosome.
fData(es5859) = geneAnnotation
# newly created, named es5859. It is an instance of an S4 class (an approach to object-oriented programming)
es5859

```
The full set of methods to which ExpressionSet instances respond can be seen using methods():

```{r}
# listing all of the different operations that are defined for instances of the class ExpressionSet
methods(class="ExpressionSet")

```
We can also use vectors to subset this expression data set:
```{r}
# making a new expression set that has only 4 features and 3 samples.
es5859[1:4, 1:3]
```

We can also subset for gene expression data on a specific chromosome.
One of the nice things about this arrangement is that we can easily select features using higher level concepts annotated in the fData and pData components. For example to obtain expression data for genes on the Y chromosome only:

```{r}
es5859[which(fData(es5859)$CHR=="chrY"),]
```


<!-- ## R Markdown -->

<!-- This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>. -->

<!-- When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this: -->

<!-- ```{r cars} -->
<!-- summary(cars) -->
<!-- ``` -->

<!-- ## Including Plots -->

<!-- You can also embed plots, for example: -->

<!-- ```{r pressure, echo=FALSE} -->
<!-- plot(pressure) -->
<!-- ``` -->

<!-- Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot. -->
